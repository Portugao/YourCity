<?php
/**
 * YourCity.
 *
 * @copyright Michael Ueberschaer (MU)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @author Michael Ueberschaer <info@homepages-mit-zikula.de>.
 * @link http://homepages-mit-zikula.de
 * @link http://zikula.org
 * @version Generated by ModuleStudio (http://modulestudio.de).
 */

namespace MU\YourCityModule\Helper\Base;

use Doctrine\ORM\QueryBuilder;
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\RequestStack;
use Zikula\Common\Translator\TranslatorInterface;
use Zikula\Core\RouteUrl;
use Zikula\PermissionsModule\Api\PermissionApi;
use MU\YourCityModule\Entity\Factory\EntityFactory;
use MU\YourCityModule\Helper\HookHelper;
use MU\YourCityModule\Helper\WorkflowHelper;

/**
 * Archive helper base class.
 */
abstract class AbstractArchiveHelper
{
    /**
     * @var TranslatorInterface
     */
    protected $translator;

    /**
     * @var Request
     */
    protected $request;

    /**
     * @var LoggerInterface
     */
    protected $logger;

    /**
     * @var PermissionApi
     */
    protected $permissionApi;

    /**
     * @var EntityFactory
     */
    protected $entityFactory;

    /**
     * @var WorkflowHelper
     */
    protected $workflowHelper;

    /**
     * @var HookHelper
     */
    protected $hookHelper;

    /**
     * ArchiveHelper constructor.
     *
     * @param TranslatorInterface $translator     Translator service instance
     * @param RequestStack        $requestStack   RequestStack service instance
     * @param LoggerInterface     $logger         Logger service instance
     * @param PermissionApi       $permissionApi  PermissionApi service instance
     * @param EntityFactory       $entityFactory  EntityFactory service instance
     * @param WorkflowHelper      $workflowHelper WorkflowHelper service instance
     * @param HookHelper          $hookHelper     HookHelper service instance
     */
    public function __construct(
        TranslatorInterface $translator,
        RequestStack $requestStack,
        LoggerInterface $logger,
        PermissionApi $permissionApi,
        EntityFactory $entityFactory,
        WorkflowHelper $workflowHelper,
        HookHelper $hookHelper)
    {
        $this->translator = $translator;
        $this->request = $requestStack->getCurrentRequest();
        $this->logger = $logger;
        $this->permissionApi = $permissionApi;
        $this->entityFactory = $entityFactory;
        $this->workflowHelper = $workflowHelper;
        $this->hookHelper = $hookHelper;
    }

    /**
     * Moves obsolete data into the archive.
     */
    public function archiveObsoleteObjects()
    {
        $randProbability = mt_rand(1, 1000);
        if ($randProbability < 750) {
            return;
        }
    
        if (!$this->permissionApi->hasPermission('MUYourCityModule', '.*', ACCESS_EDIT)) {
            // abort if current user has no permission for executing the archive workflow action
            return;
        }
    
        // perform update for offers becoming archived
        $logArgs = ['app' => 'MUYourCityModule', 'entity' => 'offer'];
        $this->logger->notice('{app}: Automatic archiving for the {entity} entity started.', $logArgs);
        $this->archiveOffers();
        $this->logger->notice('{app}: Automatic archiving for the {entity} entity completed.', $logArgs);
    
        // perform update for events becoming archived
        $logArgs = ['app' => 'MUYourCityModule', 'entity' => 'event'];
        $this->logger->notice('{app}: Automatic archiving for the {entity} entity started.', $logArgs);
        $this->archiveEvents();
        $this->logger->notice('{app}: Automatic archiving for the {entity} entity completed.', $logArgs);
    }
    
    /**
     * Moves offers into the archive which reached their end date.
     *
     * @throws RuntimeException Thrown if workflow action execution fails
     */
    protected function archiveOffers()
    {
        $today = date('Y-m-d H:i:s');
    
        $affectedEntities = $this->getObjectsToBeArchived('offer', 'enddate', $today);
        foreach ($affectedEntities as $entity) {
            $this->archiveSingleObject($entity);
        }
    }
    
    /**
     * Moves events into the archive which reached their end date.
     *
     * @throws RuntimeException Thrown if workflow action execution fails
     */
    protected function archiveEvents()
    {
        $today = date('Y-m-d H:i:s');
    
        $affectedEntities = $this->getObjectsToBeArchived('event', 'end2Date', $today);
        foreach ($affectedEntities as $entity) {
            $this->archiveSingleObject($entity);
        }
    }
    
    /**
     * Returns the list of entities which should be archived.
     *
     * @param string $objectType Name of treated entity type
     * @param string $endField   Name of field storing the end date
     * @param mixed  $endDate    Datetime or date string for the threshold date
     *
     * @return array List of affected entities
     */
    protected function getObjectsToBeArchived($objectType = '', $endField = '', $endDate = '')
    {
        $repository = $this->entityFactory->getRepository($objectType);
        $qb = $repository->genericBaseQuery('', '', false);
    
        /*$qb->andWhere('tbl.workflowState != :archivedState')
           ->setParameter('archivedState', 'archived');*/
        $qb->andWhere('tbl.workflowState = :approvedState')
           ->setParameter('approvedState', 'approved');
    
        $qb->andWhere('tbl.' . $endField . ' < :endThreshold')
           ->setParameter('endThreshold', $endDate);
    
        $query = $repository->getQueryFromBuilder($qb);
    
        return $query->getResult();
    }
    
    /**
     * Archives a single entity.
     *
     * @param object $entity The given entity instance
     *
     * @return bool True if everything worked successfully, false otherwise
     */
    protected function archiveSingleObject($entity)
    {
        $entity->initWorkflow();
    
        if ($entity->supportsHookSubscribers()) {
            // Let any hooks perform additional validation actions
            $validationHooksPassed = $this->hookHelper->callValidationHooks($entity, 'validate_edit');
            if (!$validationHooksPassed) {
                return false;
            }
        }
    
        $success = false;
        try {
            // execute the workflow action
            $success = $this->workflowHelper->executeAction($entity, 'archive');
        } catch(\Exception $exception) {
            $flashBag = $this->request->getSession()->getFlashBag();
            $flashBag->add('error', $this->translator->__f('Sorry, but an error occured during the %action% action. Please apply the changes again!', ['%action%' => $action]) . '  ' . $exception->getMessage());
        }
    
        if (!$success) {
            return false;
        }
    
        if ($entity->supportsHookSubscribers()) {
            // Let any hooks know that we have updated an item
            $objectType = $entity->get_objectType();
            $url = null;
    
            $hasDisplayPage = in_array($objectType, ['branch', 'location', 'part', 'imageOfLocation', 'fileOfLocation', 'offer', 'menuOfLocation', 'partOfMenu', 'dish', 'event', 'product', 'specialOfLocation', 'serviceOfLocation']);
            if ($hasDisplayPage) {
                $urlArgs = $entity->createUrlArgs();
                $urlArgs['_locale'] = $this->request->getLocale();
                $url = new RouteUrl('muyourcitymodule_' . strtolower($objectType) . '_display', $urlArgs);
        	}
            $this->hookHelper->callProcessHooks($entity, 'process_edit', $url);
        }
    }
}
